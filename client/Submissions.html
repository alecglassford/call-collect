<div>
  {{#if !currentSubmissions || !currentPrompts}}
    Loading submissions.
  {{else}}
    <label><input type="radio" bind:group="organize" value='prompt' checked>Group by prompt</label>
    <label><input type="radio" bind:group="organize" value='caller'>Group by caller</label>
    <label style="float: right">Search transcripts <input type="text" bind:value="search"></label>
    {{#if organize === 'prompt'}}
      {{#each currentPrompts as prompt}}
        <h3>Submissions for prompt {{humanIndex(prompt.fields.index)}}</h3>
        <table>
          <thead>
            <tr>
              <th>Timestamp</th>
              <th>Caller</th>
              <th>Audio</th>
              <th>Download</th>
            </tr>
          </thead>
          <tbody>
            {{#each filterByPrompt(searchedSubmissions, prompt.id) as submission @id}}
              <SubmissionRow :submission/>
            {{/each}}
          </tbody>
        </table>
      {{/each}}
    {{else}}
      {{#each callers as caller}}
        <h3>Submissions from {{humanPhone(caller)}}</h3>
        <table>
          <thead>
            <tr>
              <th>Timestamp</th>
              <th>Caller</th>
              <th>Audio</th>
              <th>Download</th>
            </tr>
          </thead>
          <tbody>
            {{#each filterByCaller(searchedSubmissions, caller) as submission @id}}
              <SubmissionRow :submission/>
            {{/each}}
          </tbody>
        </table>
      {{/each}}
    {{/if}}
  {{/if}}
</div>

<style>
  table {
    margin: 1em 0;
    width: 100%;
    border-collapse: collapse;
  }
</style>

<script>
  import initSoundcite from './soundcite';
  import { humanIndex, humanPhone } from './util';
  import SubmissionRow from './SubmissionRow.html';

  export default {
    components: { SubmissionRow },
    oncreate() {
      this.observe('currentSubmissions', () => {
        initSoundcite();
      }, { defer: true });
      this.observe('organize', () => { // no this sucks TK fix
        initSoundcite();
      }, { defer: true });
    },
    data() {
      return {
        currentProject: null,
        currentPrompts: null,
        currentSubmissions: null,
        organize: 'prompt',
        search: '',
      };
    },
    computed: {
      projectName: currentProject => currentProject.fields.name,
      callers: function callersFunc(currentSubmissions) {
        if (!currentSubmissions) return null;
        return Array.from(new Set(currentSubmissions.map(sub => sub.fields.caller)));
      },
      searchedSubmissions: function searchFunc(search, currentSubmissions) {
        if (!search.length) return currentSubmissions;
        const lowerSearch = search.toLowerCase();
        return currentSubmissions.filter((sub) => {
          if (!sub.fields.transcript) return false;
          return sub.fields.transcript.toLowerCase().includes(lowerSearch);
        });
      },
    },
    helpers: {
      filterByPrompt: (subs, promptId) =>
        subs.filter(sub => sub.fields.prompt[0] === promptId),
      filterByCaller: (subs, caller) =>
        subs.filter(sub => sub.fields.caller === caller),
      humanIndex,
      humanPhone,
    },
  };
</script>
