<button id="start-stop" class="{{state}}" on:click="startStop()">
  <span id="button-text">{{ stateSymbol }}</span>
</button>
{{#if state === 'loading'}}
<p>Hold on.… <Spinner/></p>
{{/if}}
{{#if state === 'recording'}}
<p>Recording.</p>
{{/if}}
{{#if audioBlob}}
  <audio src="{{audioBlobUrl}}" ref:player bind:currentTime bind:duration on:pause="pause()"></audio>
  <span>
    {{#if state === 'playing'}}{{Math.round(currentTime)}} / {{/if}}
    {{Math.round(duration)}} seconds
  </span>
  <button class="btn btn-success" on:click="upload()">Submit recording</button>
  <button class="btn btn-danger" on:click="discard()">Discard recording</button>
{{/if}}

<style>
  #start-stop {
    color: red;
    border: 2px solid red;
    border-radius: 50%;
    font-size: 2em;
    width: 1.5em;
    height: 1.5em;
    cursor: pointer;
  }

  #button-text {
    position: relative;
    bottom: 0.02em; /* this is dumb */
  }

  #start-stop.recording {
    outline: none; /* TK a11y: tabbing messed up */
    border: none;
    border-top: 2px solid red;
    animation: spin 1s linear infinite;
  }

  .recording #button-text {
    display: inline-block;
    animation: spin 1s linear infinite reverse;
  }

  #start-stop.paused {
    color: black;
    border-color: black;
  }

  #start-stop.playing {
    color: green;
    border-color: green;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
</style>

<script>
  import Recorder from 'audio-recorder-polyfill';

  import Spinner from './Spinner.html';

  const startRecording = function startRecordingFunc() { // TK refactor
    this.set({ state: 'loading' });
    const audioData = [];
    const recorder = new Recorder(null, { audio: true });
    recorder.addEventListener('dataavailable', (ev) => {
      audioData.push(ev.data);
    });
    recorder.addEventListener('stop', () => {
      const audioBlob = new Blob(audioData, { type: 'audio/wav' });
      this.set({ audioBlob });
      recorder.stream.getTracks().forEach((track) => {
        track.stop();
      });
      recorder.context.close();
    });
    recorder.start().then(() => {
      this.set({ state: 'recording', recorder });
    }).catch(() => {
      this.set({ state: 'error' });
    });
  };

  const stopRecording = function stopRecordingFunc() {
    this.get('recorder').stop();
    this.set({ state: 'paused' });
  };

  const play = function playFunc() {
    this.refs.player.play().then(() => {
      this.set({ state: 'playing' });
    });
  };

  export default {
    components: { Spinner },
    data() {
      return {
        state: 'untouched',
        recorder: null,
        audioBlob: null,
        currentTime: null,
        duration: null,
      };
    },
    computed: {
      stateSymbol(state) {
        if (state === 'untouched' || state === 'loading') return '·';
        if (state === 'recording' || state === 'playing') return '▪';
        return '▸'; // if (state === 'paused')
      },
      audioBlobUrl: audioBlob => (audioBlob ? URL.createObjectURL(audioBlob) : null),
    },
    methods: {
      startStop() { // TK use a switch statement or a function mappy thing lol
        const state = this.get('state');
        if (state === 'untouched') startRecording.call(this);
        else if (state === 'recording') stopRecording.call(this);
        else if (state === 'paused') play.call(this);
        else this.pause(); // state === 'playing'
      },
      pause() {
        this.refs.player.pause();
        this.set({ state: 'paused', currentTime: 0 });
      },
      discard() {
        this.set({
          state: 'untouched',
          recorder: null,
          audioBlob: null,
          currentTime: null,
          duration: null,
        });
      },
      upload() {
        console.log('tk');
      },
    },
  };
</script>
